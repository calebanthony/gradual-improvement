<!DOCTYPE html><html data-n-head="" data-n-head-ssr><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Personal blog for Caleb" name="description" data-hid="description"><title data-n-head="true">Gradual Improvement</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons" rel="stylesheet" data-n-head="true"><link href="/_nuxt/manifest.32a2317045b4e4318847.js" rel="preload" as="script"><link href="/_nuxt/common.c7dcbad7f44527b8d433.js" rel="preload" as="script"><link href="/_nuxt/app.2ca6beadb780e75fafec.js" rel="preload" as="script"><link href="/_nuxt/pages/index.c9b5a6ce453cf198daf4.js" rel="prefetch"><link href="/_nuxt/pages/projects/_project.2719d5fbc7468da5ac4f.js" rel="prefetch"><link href="/_nuxt/pages/essays/_essay.0fff3f964cad765c03f8.js" rel="prefetch"><link href="/_nuxt/pages/blog/_blog.533827738329e9c1c3b4.js" rel="prefetch"><link href="/_nuxt/layouts/default.3d1fc074ea196f931bfc.js" rel="prefetch"><link href="/_nuxt/common.fba3a3811fae13b5fd46e6e019a7b085.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div class="application application--light" data-app="true" id="app"><aside class="navigation-drawer navigation-drawer--close" style="height:100%;margin-top:0;max-height:calc(100% - 0px);width:300px"><nav class="primary toolbar theme--dark" style="margin-top:0;padding-left:0;padding-right:0"><div class="toolbar__content" style="height:56px"><div class="flex"><a href="https://stackoverflow.com/users/6646558/caleb-anthony" class="btn btn--icon btn--raised"><div class="btn__content"><i class="fa icon fa-stack-overflow" style="font-size:24px"></i></div></a></div><div class="flex"><a href="http://github.com/calebanthony" class="btn btn--icon btn--raised"><div class="btn__content"><i class="fa icon fa-github" style="font-size:24px"></i></div></a></div><div class="flex"><a href="https://www.linkedin.com/in/calebanthony/" class="btn btn--icon btn--raised"><div class="btn__content"><i class="fa icon fa-linkedin" style="font-size:24px"></i></div></a></div></div></nav><ul class="list" data-uid="18"><li><a href="/" class="list__tile list__tile--link"><div class="list__tile__action"><i class="material-icons icon">home</i></div><div class="list__tile__content"><div class="list__tile__title">Home</div></div></a></li><div class="list--group__container"><div class="list--group__header"><li><a href="javascript:;" class="list__tile list__tile--link"><div class="list__tile__action"><i class="material-icons icon">message</i></div><div class="list__tile__content"><div class="list__tile__title">Blog</div></div><div class="list__tile__action"><i class="material-icons icon">keyboard_arrow_down</i></div></a></div><ul class="list list--group" style="display:none"><li><a href="/blog/client-server-communication-socket-io" class="nuxt-link-exact-active list__tile--active list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Client/Server Communication</div><!----></div></a><li><a href="/blog/building-component-library" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Building a Component Library</div><!----></div></a><li><a href="/blog/laravel-mix-and-bootstrap4" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Laravel Mix with Bootstrap 4</div><!----></div></a><li><a href="/blog/building-pages-with-modularized-controllers" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Modular Pages in Laravel 5</div><!----></div></a><li><a href="/blog/bootstrap-with-laravel" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Bootstrap 4 with Laravel 5</div><!----></div></a></ul></div><div class="list--group__container"><div class="list--group__header"><li><a href="javascript:;" class="list__tile list__tile--link"><div class="list__tile__action"><i class="material-icons icon">lightbulb_outline</i></div><div class="list__tile__content"><div class="list__tile__title">Projects</div></div><div class="list__tile__action"><i class="material-icons icon">keyboard_arrow_down</i></div></a></div><ul class="list list--group" style="display:none"><li><a href="/projects/sanctum-falls" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Sanctum Falls</div><div class="list__tile__sub-title">Fansite for guides for Gigantic</div></div></a><li><a href="/projects/spook" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Spook</div><div class="list__tile__sub-title">Base theme template for Ghost</div></div></a><li><a href="/projects/town-of-salem-assistant" class="list__tile list__tile--link"><div class="list__tile__content"><div class="list__tile__title">Town of Salem Assistant</div><div class="list__tile__sub-title">Helper tool for Town of Salem</div></div></a></ul></div></ul><div class="navigation-drawer__border"></div></aside><main><div class="content" style="padding-top:0;padding-right:0;padding-bottom:0;padding-left:0"><article><div class="layout wrap"><div class="flex xs12 md11 offset-md1"><h2 class="grey--text text--darken-3">Client/Server Strategy with SocketIO</h2><h3 class="grey--text text--darken-1">Published 2017-10-04</h3></div><div class="flex xs12 md8 offset-md1"><div><p>I’m currently creating a text-based browser MMO. I’m using SocketIO to facilitate the client-server communication, as opposed to the AJAX requests typically seen in this kind of game.<p>I chose SocketIO in order to provide more functionality, like being able to see live what other players in your current location are doing, when players join / leave, and a robust chat system. All things not possible (or messy and slow at the very least) with AJAX.<p>However, that meant setting up more complicated client-server communication due to the fact that it’s not request-based, but event-based logic.<h3>Choosing My Tech</h3><p>I decided to use <a href="https://vuejs.org/">Vue</a> as the front-end of the project, as I’m using it at work and wanted to get some more experience with the framework. Plus it’s just a joy to use.<p>With that in mind, I decided to go with <a href="https://nuxtjs.org/">Nuxt</a> as my framework of choice. Nuxt allows you to build isomorphic (or universal, pick your fancy word) applications by letting the code be run on either the client or server side. Perfect for wanting to use SocketIO.<p>Finally, I used <a href="https://nodejs.org/">NodeJS</a> as the back-end. Since SocketIO is an event-driven technology anyway, Node seemed like the perfect fit. Plus I’ll be able to scale well and handle a large number of concurrent users. Perfect for an MMO.<h3>The Workflow</h3><p>Because this is a multiplayer game, it’s safe to assume that all players are cheaters. Because of this, the client’s <em>only</em> role is to handle state and present it to the user.<p><strong>All logic happens server-side.</strong><p>This means the client emits an event to the server, which handles all the logic and validation. The server then updates state in the database and emits an event back to the client. Finally the client updates its store and presents the data back to the player.<p>Because we’re using SocketIO, this round trip is blazing fast and the player will feel like his actions are happening instantaneously. Something AJAX can’t do.<p>So let’s get into the nitty-gritty.<p>Here’s a diagram showing the workflow:<div align="center"><p><img alt="Workflow" src="/clientserverstrategy/workflow.png"></div><p>Let’s break it down.<h4>The Component</h4><p>This is an individual component on the client side. This could be a chat box, map element, or set of buttons presenting actions to the user.<p>The component dispatches a Vuex action, like so:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side Component</span>
<span class="token comment" spellcheck="true">// This is called in the component template with @submit="sendMessage"</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    sendMessage <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> newChat <span class="token operator">=</span> <span class="token punctuation">{</span>
        name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chat<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
        author<span class="token punctuation">:</span> <span class="token string">'You'</span><span class="token punctuation">,</span>
        message<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newMessage
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'chat/createMessage'</span><span class="token punctuation">,</span> newChat<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>newMessage <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Each component only cares about assembling data and dispatching actions to the store. This keeps our component methods clean and readable.<p>The component also gets its data from the Vuex store. This means we can set up grabbing the data once and then leave it. Great!<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side Component</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    chats <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>list <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><hr><h4>Vuex Store</h4><p>This is where the meat of the client-side logic happens. While components only care about receiving and sending data, the store cares about updating state.<p>All my store objects are namespaced into modules. This means all chat-related actions and mutations happen in <code>/store/chat.js</code>. This means I can also name my actions more freely. For example <code>$store.dispatch('chat/createMessage')</code> in the store is actually just <code>createMessage</code>, but in the <code>chat</code> namespace.<p>More on this at the end of the post, but honestly I think this is a no-brainer if you expect your project to reach any sort of scale.<p>So in the store’s chat module, we handle the action dispatched by the component:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>
actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  createMessage <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    socket<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'createMessage'</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Because actions are asynchronous, we could do a lot more in this action if we wanted to. Maybe we emit multiple events to the server. Or maybe we check the message for nasty language before processing it. Use your imagination.<p>This pretty solidly future-proofs our actions so we can scale as much as we need.<p><strong>So what’s next?</strong> The client has emitted an event via SocketIO to the server so let’s head over there and see what’s happening.<hr><h4>Server Store</h4><p>Now this isn’t Vuex but it’s still separated by directory structure so that it acts the same way the client-side store does.<p>In my <code>/sockets/chat.js</code> file, I can see all incoming events and then send out actions to my controllers.<p>We don’t receive events directly on the controllers for the same reason we don’t emit events directly on components client-side. We want to make room for scale.<p>So in the future, when we add a new feature (like private chat groups for example), we can simply add a controller method (or a whole new store/controller combo) to our <code>/sockets/chat.js</code> file and we’re good to go. No need to get spaghetti code everywhere in our controllers.<p>So an example of server store:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>
chat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'createMessage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'broadcastMessage'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>In this case, we don’t use a controller yet, we’re just emitting the data right back to the client.<p>But if we wanted to, we could:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>
<span class="token keyword">const</span> ChatController <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../controllers/ChatController'</span><span class="token punctuation">)</span>

chat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'createMessage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cleanText <span class="token operator">=</span> ChatController<span class="token punctuation">.</span><span class="token function">noSwearing</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'broadcastMessage'</span><span class="token punctuation">,</span> cleanText<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>Plus we could emit other events, call as many controller methods as we want, and generally just add logic willy-nilly without stressing too much. If it gets <em>too</em> crazy, just abstract some method calls into a single method.<p>Plus doing it this way allows us to keep our code extremely readable and testable (yay!). You don’t need to look at the controller to know what it does.<p>If you needed to do a DB lookup with the player’s data, you could just pass through the SocketIO object (which you attach the player ID to during authentication) and do all your logic straight from the method.<p>Excellent.<p>And really, that’s all you should ever need. Since we don’t trust the client, we are only receiving what the client <em>wants</em> to do. Then we do all our checking and the actual action on the server. So all you’ll ever need is intent and a player ID.<hr><h3>Back to the Vuex Store</h3><p>Once the server does its logic, it will emit an event containing only the data the client needs to update.<p>This gets pulled into the store on the client side:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>
io<span class="token punctuation">:</span> <span class="token punctuation">(</span>store<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'broadcastMessage'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'chat/createMessage'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>You can see that after we’ve received the event, we commit a mutation which changes the state. We’re also namespacing the commit, which we mentioned earlier and we’ll go into more depth in a second.<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>
mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  createMessage <span class="token punctuation">(</span>state<span class="token punctuation">,</span> chat<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>list<span class="token punctuation">[</span>chat<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span>messages<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      author<span class="token punctuation">:</span> chat<span class="token punctuation">.</span>author<span class="token punctuation">,</span>
      message<span class="token punctuation">:</span> chat<span class="token punctuation">.</span>message
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>This gets received by the component, which updates the view for the user. Full circle!<p>Let’s dig a little bit deeper to see how exactly the store-to-store (client/server) communication works:<hr><h4>Keeping Things Clean</h4><p>You may have noticed that we didn’t namespace our SocketIO events. “Won’t that get terribly messy?” you think…<p>Well…technically we did.<p>This is because they’re already namespaced.<p>On the client-side we have our events namespaced automatically due to the namespacing of Vuex.<p>On the server-side, we namespace our events by separating our logic into equivalently-named files under <code>/sockets/</code>.<p>Let’s see:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side directory structure</span>
<span class="token operator">-</span> <span class="token operator">/</span>store
  <span class="token operator">-</span> index<span class="token punctuation">.</span>js <span class="token comment" spellcheck="true">// Handles importing all the modules</span>
  <span class="token operator">-</span> chat<span class="token punctuation">.</span>js
  <span class="token operator">-</span> map<span class="token punctuation">.</span>js
  <span class="token operator">-</span> etc<span class="token punctuation">.</span>js

<span class="token comment" spellcheck="true">// Server-side directory structure</span>
<span class="token operator">-</span> <span class="token operator">/</span>sockets
  <span class="token operator">-</span> index<span class="token punctuation">.</span>js <span class="token comment" spellcheck="true">// Handles importing all the modules</span>
  <span class="token operator">-</span> chat<span class="token punctuation">.</span>js
  <span class="token operator">-</span> map<span class="token punctuation">.</span>js
  <span class="token operator">-</span> etc<span class="token punctuation">.</span>js
</code></pre><p>Because of this matching, we can work confidently knowing that namespaces are equal across client and server and our event logic stays isolated. The way it should be.<p>“But wait, you can’t just name files the same and expect things to just work?”<p>Right you are.<p>Let’s see what these <code>index.js</code> files look like.<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Client-side /store/index.js</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">import</span> io <span class="token keyword">from</span> <span class="token string">'~/plugins/socket.io'</span>

<span class="token comment" spellcheck="true">// Import components</span>
<span class="token keyword">import</span> chatModule <span class="token keyword">from</span> <span class="token string">'./chat'</span>
<span class="token keyword">import</span> mapModule <span class="token keyword">from</span> <span class="token string">'./map'</span>
<span class="token keyword">import</span> authModule <span class="token keyword">from</span> <span class="token string">'./auth'</span>

<span class="token comment" spellcheck="true">// Set up the modules by passing them a namespaced SocketIO instance</span>
<span class="token keyword">const</span> chat <span class="token operator">=</span> <span class="token function">chatModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>chat<span class="token punctuation">)</span>
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">mapModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>map<span class="token punctuation">)</span>
<span class="token keyword">const</span> auth <span class="token operator">=</span> <span class="token function">authModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>auth<span class="token punctuation">)</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      chat<span class="token punctuation">,</span>
      map<span class="token punctuation">,</span>
      auth
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      chat<span class="token punctuation">.</span>io<span class="token punctuation">,</span>
      map<span class="token punctuation">.</span>io
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> store
</code></pre><p>The code is clean, self-documenting and easily expandable.<p>What about the server-side?<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Server-side /sockets/index.js</span>
<span class="token keyword">const</span> socketio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'socket.io'</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Get the modules</span>
<span class="token keyword">const</span> handleChat <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./chat'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> handleMap <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./map'</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Export this as a module that can easily be called in our server's root index.js</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>listen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>app<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> io <span class="token operator">=</span> socketio<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>

  <span class="token comment" spellcheck="true">// Pass through the SocketIO object</span>
  <span class="token function">handleChat</span><span class="token punctuation">(</span>io<span class="token punctuation">)</span>
  <span class="token function">handleMap</span><span class="token punctuation">(</span>io<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>And then we add namespacing in each individual module:<pre class="language-javascript"><code class="language-javascript">
<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>io<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chat <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'/chat'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Set the namespace here</span>

  <span class="token comment" spellcheck="true">// Listen for events like normal</span>
  chat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'createMessage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'broadcastMessage'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>Because we set things up this way, we have flexibility to add lots of new features without worrying about cluttering anything up.<p>If we need, we can just throw some logic into its own module, match it up with the module on the client-side, and we’re done.<p>It just works.</div></div></div></article></div></main></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{post:{title:"Client/Server Strategy with SocketIO",meta:{index:0,fileName:"2017-10-04-ClientServerCommunicationSocketIO.md",section:"/",dirName:"/blog",filePath:"/Volumes/Code/personal-dev/blog/content/blog/2017-10-04-ClientServerCommunicationSocketIO.md"},date:"2017-10-04",path:"/blog/blog/client-server-communication-socket-io",permalink:"/blog/client-server-communication-socket-io",anchors:[],body:'<p>I’m currently creating a text-based browser MMO. I’m using SocketIO to facilitate the client-server communication, as opposed to the AJAX requests typically seen in this kind of game.</p>\n<p>I chose SocketIO in order to provide more functionality, like being able to see live what other players in your current location are doing, when players join / leave, and a robust chat system. All things not possible (or messy and slow at the very least) with AJAX.</p>\n<p>However, that meant setting up more complicated client-server communication due to the fact that it’s not request-based, but event-based logic.</p>\n<h3>Choosing My Tech</h3>\n<p>I decided to use <a href="https://vuejs.org/">Vue</a> as the front-end of the project, as I’m using it at work and wanted to get some more experience with the framework. Plus it’s just a joy to use.</p>\n<p>With that in mind, I decided to go with <a href="https://nuxtjs.org/">Nuxt</a> as my framework of choice. Nuxt allows you to build isomorphic (or universal, pick your fancy word) applications by letting the code be run on either the client or server side. Perfect for wanting to use SocketIO.</p>\n<p>Finally, I used <a href="https://nodejs.org/">NodeJS</a> as the back-end. Since SocketIO is an event-driven technology anyway, Node seemed like the perfect fit. Plus I’ll be able to scale well and handle a large number of concurrent users. Perfect for an MMO.</p>\n<h3>The Workflow</h3>\n<p>Because this is a multiplayer game, it’s safe to assume that all players are cheaters. Because of this, the client’s <em>only</em> role is to handle state and present it to the user.</p>\n<p><strong>All logic happens server-side.</strong></p>\n<p>This means the client emits an event to the server, which handles all the logic and validation. The server then updates state in the database and emits an event back to the client. Finally the client updates its store and presents the data back to the player.</p>\n<p>Because we’re using SocketIO, this round trip is blazing fast and the player will feel like his actions are happening instantaneously. Something AJAX can’t do.</p>\n<p>So let’s get into the nitty-gritty.</p>\n<p>Here’s a diagram showing the workflow:</p>\n<div align="center">\n<p><img src="/clientserverstrategy/workflow.png" alt="Workflow"></p>\n</div>\n<p>Let’s break it down.</p>\n<h4>The Component</h4>\n<p>This is an individual component on the client side. This could be a chat box, map element, or set of buttons presenting actions to the user.</p>\n<p>The component dispatches a Vuex action, like so:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side Component</span>\n<span class="token comment" spellcheck="true">// This is called in the component template with @submit="sendMessage"</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    sendMessage <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token keyword">const</span> newChat <span class="token operator">=</span> <span class="token punctuation">{</span>\n        name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chat<span class="token punctuation">.</span>name<span class="token punctuation">,</span>\n        author<span class="token punctuation">:</span> <span class="token string">\'You\'</span><span class="token punctuation">,</span>\n        message<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newMessage\n      <span class="token punctuation">}</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'chat/createMessage\'</span><span class="token punctuation">,</span> newChat<span class="token punctuation">)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>newMessage <span class="token operator">=</span> <span class="token string">\'\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>Each component only cares about assembling data and dispatching actions to the store. This keeps our component methods clean and readable.</p>\n<p>The component also gets its data from the Vuex store. This means we can set up grabbing the data once and then leave it. Great!</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side Component</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    chats <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>list <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<hr>\n<h4>Vuex Store</h4>\n<p>This is where the meat of the client-side logic happens. While components only care about receiving and sending data, the store cares about updating state.</p>\n<p>All my store objects are namespaced into modules. This means all chat-related actions and mutations happen in <code>/store/chat.js</code>. This means I can also name my actions more freely. For example <code>$store.dispatch(\'chat/createMessage\')</code> in the store is actually just <code>createMessage</code>, but in the <code>chat</code> namespace.</p>\n<p>More on this at the end of the post, but honestly I think this is a no-brainer if you expect your project to reach any sort of scale.</p>\n<p>So in the store’s chat module, we handle the action dispatched by the component:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>\nactions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  createMessage <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    socket<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">\'createMessage\'</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>Because actions are asynchronous, we could do a lot more in this action if we wanted to. Maybe we emit multiple events to the server. Or maybe we check the message for nasty language before processing it. Use your imagination.</p>\n<p>This pretty solidly future-proofs our actions so we can scale as much as we need.</p>\n<p><strong>So what’s next?</strong> The client has emitted an event via SocketIO to the server so let’s head over there and see what’s happening.</p>\n<hr>\n<h4>Server Store</h4>\n<p>Now this isn’t Vuex but it’s still separated by directory structure so that it acts the same way the client-side store does.</p>\n<p>In my <code>/sockets/chat.js</code> file, I can see all incoming events and then send out actions to my controllers.</p>\n<p>We don’t receive events directly on the controllers for the same reason we don’t emit events directly on components client-side. We want to make room for scale.</p>\n<p>So in the future, when we add a new feature (like private chat groups for example), we can simply add a controller method (or a whole new store/controller combo) to our <code>/sockets/chat.js</code> file and we’re good to go. No need to get spaghetti code everywhere in our controllers.</p>\n<p>So an example of server store:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>\nchat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'connection\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'createMessage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">\'broadcastMessage\'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>In this case, we don’t use a controller yet, we’re just emitting the data right back to the client.</p>\n<p>But if we wanted to, we could:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>\n<span class="token keyword">const</span> ChatController <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'../controllers/ChatController\'</span><span class="token punctuation">)</span>\n\nchat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'connection\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'createMessage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> cleanText <span class="token operator">=</span> ChatController<span class="token punctuation">.</span><span class="token function">noSwearing</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n    chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">\'broadcastMessage\'</span><span class="token punctuation">,</span> cleanText<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>Plus we could emit other events, call as many controller methods as we want, and generally just add logic willy-nilly without stressing too much. If it gets <em>too</em> crazy, just abstract some method calls into a single method.</p>\n<p>Plus doing it this way allows us to keep our code extremely readable and testable (yay!). You don’t need to look at the controller to know what it does.</p>\n<p>If you needed to do a DB lookup with the player’s data, you could just pass through the SocketIO object (which you attach the player ID to during authentication) and do all your logic straight from the method.</p>\n<p>Excellent.</p>\n<p>And really, that’s all you should ever need. Since we don’t trust the client, we are only receiving what the client <em>wants</em> to do. Then we do all our checking and the actual action on the server. So all you’ll ever need is intent and a player ID.</p>\n<hr>\n<h3>Back to the Vuex Store</h3>\n<p>Once the server does its logic, it will emit an event containing only the data the client needs to update.</p>\n<p>This gets pulled into the store on the client side:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>\nio<span class="token punctuation">:</span> <span class="token punctuation">(</span>store<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'broadcastMessage\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'chat/createMessage\'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>You can see that after we’ve received the event, we commit a mutation which changes the state. We’re also namespacing the commit, which we mentioned earlier and we’ll go into more depth in a second.</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side /store/chat.js</span>\nmutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  createMessage <span class="token punctuation">(</span>state<span class="token punctuation">,</span> chat<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>list<span class="token punctuation">[</span>chat<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span>messages<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      author<span class="token punctuation">:</span> chat<span class="token punctuation">.</span>author<span class="token punctuation">,</span>\n      message<span class="token punctuation">:</span> chat<span class="token punctuation">.</span>message\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>This gets received by the component, which updates the view for the user. Full circle!</p>\n<p>Let’s dig a little bit deeper to see how exactly the store-to-store (client/server) communication works:</p>\n<hr>\n<h4>Keeping Things Clean</h4>\n<p>You may have noticed that we didn’t namespace our SocketIO events. “Won’t that get terribly messy?” you think…</p>\n<p>Well…technically we did.</p>\n<p>This is because they’re already namespaced.</p>\n<p>On the client-side we have our events namespaced automatically due to the namespacing of Vuex.</p>\n<p>On the server-side, we namespace our events by separating our logic into equivalently-named files under <code>/sockets/</code>.</p>\n<p>Let’s see:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side directory structure</span>\n<span class="token operator">-</span> <span class="token operator">/</span>store\n  <span class="token operator">-</span> index<span class="token punctuation">.</span>js <span class="token comment" spellcheck="true">// Handles importing all the modules</span>\n  <span class="token operator">-</span> chat<span class="token punctuation">.</span>js\n  <span class="token operator">-</span> map<span class="token punctuation">.</span>js\n  <span class="token operator">-</span> etc<span class="token punctuation">.</span>js\n\n<span class="token comment" spellcheck="true">// Server-side directory structure</span>\n<span class="token operator">-</span> <span class="token operator">/</span>sockets\n  <span class="token operator">-</span> index<span class="token punctuation">.</span>js <span class="token comment" spellcheck="true">// Handles importing all the modules</span>\n  <span class="token operator">-</span> chat<span class="token punctuation">.</span>js\n  <span class="token operator">-</span> map<span class="token punctuation">.</span>js\n  <span class="token operator">-</span> etc<span class="token punctuation">.</span>js\n</code></pre>\n<p>Because of this matching, we can work confidently knowing that namespaces are equal across client and server and our event logic stays isolated. The way it should be.</p>\n<p>“But wait, you can’t just name files the same and expect things to just work?”</p>\n<p>Right you are.</p>\n<p>Let’s see what these <code>index.js</code> files look like.</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Client-side /store/index.js</span>\n<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token keyword">import</span> io <span class="token keyword">from</span> <span class="token string">\'~/plugins/socket.io\'</span>\n\n<span class="token comment" spellcheck="true">// Import components</span>\n<span class="token keyword">import</span> chatModule <span class="token keyword">from</span> <span class="token string">\'./chat\'</span>\n<span class="token keyword">import</span> mapModule <span class="token keyword">from</span> <span class="token string">\'./map\'</span>\n<span class="token keyword">import</span> authModule <span class="token keyword">from</span> <span class="token string">\'./auth\'</span>\n\n<span class="token comment" spellcheck="true">// Set up the modules by passing them a namespaced SocketIO instance</span>\n<span class="token keyword">const</span> chat <span class="token operator">=</span> <span class="token function">chatModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>chat<span class="token punctuation">)</span>\n<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">mapModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>map<span class="token punctuation">)</span>\n<span class="token keyword">const</span> auth <span class="token operator">=</span> <span class="token function">authModule</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>auth<span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      chat<span class="token punctuation">,</span>\n      map<span class="token punctuation">,</span>\n      auth\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      chat<span class="token punctuation">.</span>io<span class="token punctuation">,</span>\n      map<span class="token punctuation">.</span>io\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> store\n</code></pre>\n<p>The code is clean, self-documenting and easily expandable.</p>\n<p>What about the server-side?</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Server-side /sockets/index.js</span>\n<span class="token keyword">const</span> socketio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'socket.io\'</span><span class="token punctuation">)</span>\n\n<span class="token comment" spellcheck="true">// Get the modules</span>\n<span class="token keyword">const</span> handleChat <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./chat\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> handleMap <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./map\'</span><span class="token punctuation">)</span>\n\n<span class="token comment" spellcheck="true">// Export this as a module that can easily be called in our server\'s root index.js</span>\nmodule<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>listen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>app<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> io <span class="token operator">=</span> socketio<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>\n\n  <span class="token comment" spellcheck="true">// Pass through the SocketIO object</span>\n  <span class="token function">handleChat</span><span class="token punctuation">(</span>io<span class="token punctuation">)</span>\n  <span class="token function">handleMap</span><span class="token punctuation">(</span>io<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>And then we add namespacing in each individual module:</p>\n<pre class="language-javascript"><code class="language-javascript">\n<span class="token comment" spellcheck="true">// Server-side /sockets/chat.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>io<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> chat <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'/chat\'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Set the namespace here</span>\n\n  <span class="token comment" spellcheck="true">// Listen for events like normal</span>\n  chat<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'connection\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'createMessage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      chat<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">\'broadcastMessage\'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>Because we set things up this way, we have flexibility to add lots of new features without worrying about cluttering anything up.</p>\n<p>If we need, we can just throw some logic into its own module, match it up with the module on the client-side, and we’re done.</p>\n<p>It just works.</p>\n'}}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.32a2317045b4e4318847.js"></script><script defer src="/_nuxt/common.c7dcbad7f44527b8d433.js"></script><script defer src="/_nuxt/app.2ca6beadb780e75fafec.js"></script>